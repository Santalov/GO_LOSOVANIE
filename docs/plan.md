# Возможный план разработки

## Три этапа

1. Минимальный работающий блокчейн
2. Блокчейн с системой голосования
3. Финальная, версия с кучей фич

На каждом этапе должна получаться полностью рабочая, отлаженная система. Идея в том, 
чтобы не пилить много фич одновременно и потом упереться в то, что это невозможно отладить, а постепенно получать работающие версии, а затем их улучшать.

### Минимальный работающий блокчейн

На этом этапе система должна уметь организовываться в сеть (без консенсуса), 
создавать транзакции, распространять их и валидировать, создавать блоки, 
распространять их, валидировать и сохранять, выдавать наружу информацию 
о любом блоке и любой транзакции.

Состав системы:
* Сервер
	1. Модуль хранения данных. Должен уметь хранить блоки и выдавать наружу данные по 
	любому блоки и любой транзакции. Инкапсулирует соединение с PostgreSQL и работу с таблицами и индексами.
	Реализовывается в виде класса с методами:
		+ Инициализация: аргументы - параметры подключения к бд, ничего не возвращает.
		+ Сохранения блока: аргумент - блок в сериализованном виде, возвращает номер блока по порядку.
		+ Получение блоков: аргумент - массив подписей блоков (или хешей, в зависимости от консенсуса), возвращает массив сериализованных блоков и их номера.
		+ Получение списка транзакций: аргумент - массив txid, возвращает массив сериализованных транзакций с номерами и хешами блоков, в которых эти транзакции находятся.
		+ Получение всех блоков: аргумент - номер страницы, количество блоков на странице, возвращает массив блоков, номер страницы, количество блоков всего, количество оставшихся страниц
		+ Получение количества блоков.
		+ Очистка базы данных.
		+ Загрузка в базу данных массива блоков: нужно для синхронизации состояния при запуске сети. Аргумет - массив блоков, на выходе массив номеров блоков.
		
	2. Модуль сети для общения с клиентом. Инкапсулирует работу с запросами клиента.
	Реализовывается в виде класса с методами:
		+ Инициализация: аргуметы - параметры сети (порт, хост, еще что-то)
	Модуль должен создавать (то есть биндить) rest сервер, слушающий какой-то порт.
	Сокеты на первом этапе не делаем. Для описания api используем язык openApi, по
	которому потом можно сгенерировать клиентский и серверный код (должна быть крутая технология). 
		Апи должно давать клиенту следующие методы:
			+ Получение транзакциий по массиву txid. Кроме самой транзакции должно возвращаться количество созданных блоков после того, в котором лежит эта транзакция и хеш и номер блока, в котором лежит эта транзакция.
			+ Отправка транзакции. Полученную от клиента транзу модуль должен отдать модулю управления нодой (см ниже) и вернуть клиенту информацию, была ли им воспринята транзакция.
			+ Получение всех транзакций по массиву публичных ключей: сервер должен клиенту вернуть все транзакции, в которых в выходах и входах есть его публичный ключ.
			+ Получение транзакций с непотраченными выходами по массиву публичных ключей.
			
	3. Модуль консенсуса. Консенсус выполняет следующую задачу: получает список транзакций, формирует блок (или получает его от другого сервера) и возвращает этот блок другим модулям. Модуль внутри себя инкапсулирует часть сетевого взаимодействия межу серверами через модуль сетевого взаимодействия (рассылку блоков, получение блоков, получение списка серверов). На первом этапе консенсуса не будет - сервер, создающий блок, будет выбираться по порядку.
	Реализовывается в виде класса с одним методом:
		+ Отправка транзакций: аргумент - массив сериализованных транзакций и хеш последнего блока, возвращает блок, который не обязательно содержит транзакции из аргумета, а так же может содержать новые. Вызов метода долгий: поток ставится на паузу и ждет когда будет создан новый блок. После получения блока нужно убирать из памяти транзакции, которые в него попали, и в следующий вызов метода отсылать только не попавшие.
		+ Получение блока: аргумент - сериализованный блок. Когда блок приходит в модуль сетевого взаимодействия с серверами, вызывается этот колбек.
		
		
	4. Модуль сериализации. Класс со следующими методами:
		+ Сериализация транзакции
		+ Десериализация транзакции
		+ Десериализация блока.
		+ Сериализация блока
		
	5. Модуль сетевога взаимодействия с серверами. Реализует синхронизацию состояния блокчейна. Методы:
		+ Инициализация: аргумент - параметры соединения (порт, хост, список других серверов).
		+ Получение всех блоков: выкачивание из сети серверов всех блоков, конкретный алгоритм взаимодействия между серверами инкапсулируется.
		+ Отправка транзации в сеть: аргумент - сериализованная транзакция. Рассылает всем участникам сети в клиентское апи транзакцию.
		+ Отправка блока всем участниками сети: аргумент - сериализованный блок.
		
	6. Модуль управления блокчейном. Инициализирует и связывает между собой все модули, управляет очередью транзакций, выполняет транзакции одну за другой, валидирует их, валидирует блоки. Отправляет блоки модулю хранения данных, отправляет транзакции в модуль консенсуса. Получает транзакции из модуля сетевого взаимодействия с клиентом, дли их проверки запрашивает данные из модуля хранения. При запуске сервера запрашивает все блоки из модуля сетевого взаимодействия с серверами и сохраняет их в модуле хранения. Класс предоставляет наружу следующие методы:
		+ Добавление транзакции в очередь: аргумент - сериализованная транзакция, на выходе либо сообщение об ошибке, если транзакция невалидная, либо сообщение об успехе
	6. Модуль криптографии. Подписи, хеши.
		+ Подпись транзакции: на входе - сериализованная транзакция, на выходе - подпись для транзакции.
		+ Проверка подписи: на входе хеш, публичный ключ, подпись - на выходе true или false
		+ Подпись блока: на входе - сериализованный блок без подписи, на выходе - подпись для блока
		+ Генерация ключей
		
* Клиент
	1. Генерация ключей
	2. Создание транзакции
	3. Отправка транзакций в блокчейн
	4. Проверка баланса
	5. Получение истории транзакций
	6. Интерфейс командной строки